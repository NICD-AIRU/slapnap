

# ---------------------------------------------------------------------------- #
# given an aligned sequence string, create an HXB2 map-like object
# ---------------------------------------------------------------------------- #


mk.hxb2.map <- function (hxb2.seq) {

  # define an alphabet object for marking insertions
  alphabet <- c ("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", 
                 "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", 
                 "y", "z")

  # initialize our map object
  map <- data.frame (posNum=1:nchar (hxb2.seq), 
                     hxb2Pos=rep (NA, nchar (hxb2.seq)),
                     hxb2aa=rep (NA, nchar (hxb2.seq)))

  # loop through each position
  hxb2.pos <- 0
  gap.count <- 0
  for (pos in 1:nchar (hxb2.seq)) {

    # what is our residue at this position?
    residue <- substr (hxb2.seq, pos, pos)
    map[pos, 3] <- residue

    # our residue is not a gap
    if (substr (hxb2.seq, pos, pos) != "-") {
      hxb2.pos <- hxb2.pos + 1
      gap.count <- 0
      map[pos, 2] <- hxb2.pos

    # our "residue" is a gap
    } else {
      gap.count <- gap.count + 1
      map[pos, 2] <- paste0 (hxb2.pos, alphabet[gap.count %% 26])
    }
  }

  # finished; return our complete map object
  return (map)
}


# ---------------------------------------------------------------------------- #
# convert a vector of residue information into vectorized binary indicators
# ---------------------------------------------------------------------------- #


aa.char.2.aa.binary <- function (seq, seqnames, map) {

  # define our results object
  results <- NULL

  # define our data alphabet, with natural-language descriptions
  aa.chars <- c ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 
                 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z', '-', 
                 "*", '$', '?', '#')
  aa.names <- c ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 
                 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z', 'gap', 
                 'stop_asterisk', 'stop_dollar', 'question', 'frameshift')

  # initialize our results object
  results <- matrix (NA, nrow=length (seq), ncol=nrow (map) * length (aa.names))
  colnames (results) <- paste ("hxb2", rep (map[, 2], each=length (aa.names)), aa.names, "1mer", sep=".")

  # loop through each sequence
  for (seqindex in 1:length (seqnames)) {

    # initialize the information required for this sequence
    seqname.tmp <- seqnames[seqindex]    
    seq.tmp <- as.vector (seq[[seqname.tmp]])
    results.row <- NULL

    # loop through each position
    for (pos in 1:length (seq.tmp)) {

      # our temporary results for this residue
      results.tmp <- rep (0, length (aa.names))

      # turn on the bit for our observed residue/code
      results.tmp[aa.chars == seq.tmp[pos]] <- 1

      # append to our master results
      results.row <- append (results.row, results.tmp)
    }

    # we've compiled a row of results, so let's add it to the object
    results[seqindex, ] <- results.row
  }

  # return our results
  return (results)
}


# ---------------------------------------------------------------------------- #
# convert country into geographic region
# ---------------------------------------------------------------------------- #


country.2.geo.reg <- function (country) {

  # define our regions and the countries within them
  asia <- c ("CN", "IN", "JP", "TH")
  n.africa <- c ("CM", "CG", "CI", "CD", "ET", "KE", "RW", "SN", "TZ", "UG")
  s.africa <- c ("BW", "MW", "ZA", "ZM")
  euro <- c ("BE", "CH", "ES", "FR", "GB", "IT", "NL")
  amer <- c ("BR", "DO", "HT", "PE", "TT", "US")

  # initialize and create our univariate/text results variable
  results.tmp <- rep (NA, length (country))  
  results.tmp[country %in% asia] <- "Asia"
  results.tmp[country %in% n.africa] <- "N.Africa"
  results.tmp[country %in% s.africa] <- "S.Africa"
  results.tmp[country %in% euro] <- "Europe"
  results.tmp[country %in% amer] <- "Americas"

  # split into binary indicators
  results <- matrix (NA, nrow=length (country), ncol=length (levels (factor (results.tmp))))
  colnames (results) <- levels (factor (results.tmp))
  for (region.tmp in levels (factor (results.tmp))) {
    results[, region.tmp] <- as.numeric (results.tmp == region.tmp)
  }
  colnames (results) <- paste0 ("geographic.region.of.origin.is.", colnames (results))

  # we're done, let's wrap it up
  return (results)
}


# ---------------------------------------------------------------------------- #
# bin our subtype by major subtypes and "Other"
# ---------------------------------------------------------------------------- #


bin.subtype <- function (subtype) {

  # define our subtype bins
  subtype.bins <- c ("01_AE", "02_AG", "07_BC", "A1", "B", "C", "D")

  # initialize our results object
  results <- matrix (NA, nrow=length (subtype), ncol=length (subtype.bins) + 1)
  colnames (results) <- c (subtype.bins, "Other")
  for (subtype.bin in subtype.bins) {
    results[, subtype.bin] <- as.numeric (subtype == subtype.bin)
  }
  colnames (results) <- paste0 ("subtype.is.", colnames (results))

  # bin as "Other" if necessary
  results[, ncol (results)] <- as.numeric (rowSums (results, na.rm=T) == 0)

  # take me home, country road
  return (results)
}


# ---------------------------------------------------------------------------- #
# calculate the geometric mean
# ---------------------------------------------------------------------------- #


geometric.mean <- function (x, na.rm=TRUE) {
  return (exp (sum (log (x[x > 0]), na.rm=na.rm) / length (x)))
}


# ---------------------------------------------------------------------------- #
# given a vector of IC50/IC80 readouts, impute the censored cases and 
# calculate the geometric mean
# ---------------------------------------------------------------------------- #


merge.readouts <- function (readouts) {

  # remove all empty values
  readouts <- readouts[readouts != ""]

  # create our new readouts, imputing when necessary
  readouts.new <- rep (NA, length (na.omit (readouts)))
  readouts.new[!(substr (readouts, 1, 1) %in% c (">", "<"))] <- as.numeric (as.character (readouts[!(substr (readouts, 1, 1) %in% c (">", "<"))]))
  readouts.new[substr (readouts, 1, 1) == ">"] <- (as.numeric (substr (readouts[substr (readouts, 1, 1) == ">"], 2, nchar (as.character (readouts[substr (readouts, 1, 1) == ">"])))) * 2)
  readouts.new[substr (readouts, 1, 1) == "<"] <- (as.numeric (substr (readouts[substr (readouts, 1, 1) == "<"], 2, nchar (as.character (readouts[substr (readouts, 1, 1) == "<"])))) / 2)

  # return the geometric mean
  return (geometric.mean (readouts.new))
}


# ---------------------------------------------------------------------------- #
# perform the Wagh et al. additive method
# ---------------------------------------------------------------------------- #


wagh.additive.method <- function (x) {
  return (1 / sum (1 / x))
}


# ---------------------------------------------------------------------------- #
#                                    - 30 -
# ---------------------------------------------------------------------------- #


